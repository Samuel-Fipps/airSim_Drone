diff --git a/main.py b/main.py
index 9d30e78..613bf2c 100644
--- a/main.py
+++ b/main.py
@@ -2,13 +2,9 @@ import yaml
 import gym
 import time
 import torch
-import matplotlib.pyplot as plt
-import torch.nn as nn
 
-from stable_baselines3 import A2C
-from stable_baselines3 import DQN
 from stable_baselines3.common.monitor import Monitor
-from stable_baselines3.common.vec_env import DummyVecEnv, VecTransposeImage, SubprocVecEnv 
+from stable_baselines3.common.vec_env import DummyVecEnv, VecTransposeImage
 from stable_baselines3.common.evaluation import evaluate_policy
 from stable_baselines3.common.callbacks import EvalCallback
 from stable_baselines3 import PPO
@@ -26,7 +22,9 @@ env = DummyVecEnv (
                 "scripts:airsim-env-v0", 
                 ip_address="127.0.0.1",
                 image_shape = (720, 1280, 3),
-                env_config=env_config["TrainEnv"]
+                env_config=env_config["TrainEnv"],
+                #step_length=0.25,
+                step_length=4,
             )
         )
     ]
@@ -35,29 +33,6 @@ env = DummyVecEnv (
 # Wrap env as VecTransposeImage to allow SB to handle frame observations
 env = VecTransposeImage(env)
 
-"""
-# Initialize RL algorithm type and parameters
-model = DQN(
-    "CnnPolicy",
-    env,
-    learning_rate=0.00025,
-    verbose=1,
-    batch_size=32,
-    train_freq=4,
-    target_update_interval=10000,
-    learning_starts=10000,
-    #buffer_size=500000,
-    buffer_size=5000, 
-    #buffer_size=90000, not 3d 
-    max_grad_norm=10,
-    exploration_fraction=0.1,
-    exploration_final_eps=0.01,
-    device="cpu",
-    tensorboard_log="./tb_logs/",
-)
-"""
-
-
 # Initialize RL algorithm type and parameters
 model = PPO(
     policy="CnnPolicy",
@@ -99,11 +74,12 @@ kwargs["callback"] = callbacks
 # Train for a certain number of timesteps
 model.learn(
     total_timesteps=5e5,
-    tb_log_name="dqn_airsim_drone_run_" + str(time.time()),
+    tb_log_name="ppo_airsim_drone_run_" + str(time.time()),
     **kwargs,
     #progress_bar=True
 )
 
 
 # Save policy weights
-model.save("dqn_airsim_drone_policy")
\ No newline at end of file
+model.save("ppo_airsim_drone_policy")
+
diff --git a/scripts/airsim_env.py b/scripts/airsim_env.py
index 31957d5..02ae6f0 100644
--- a/scripts/airsim_env.py
+++ b/scripts/airsim_env.py
@@ -5,7 +5,7 @@ import airsim
 import math
 import time
 import gym
-
+import cv2
 
 first_pass = 1
 counter = 0
@@ -27,24 +27,39 @@ elapsed_time_2 =0
 step_counter = 0
 continues_to_be_bad = 1
 within_distance_counter = 0 
+pic_counter = 0
+debug_counter = 0
 
+def interpolate_velocity(current_v, target_v, steps=10):
+    return np.linspace(current_v, target_v, steps)
 
 class AirSimDroneEnv(gym.Env):
-    def __init__(self, ip_address, image_shape, env_config):
+    def __init__(self, ip_address, image_shape, env_config, step_length):
         self.image_shape = image_shape
         self.sections = env_config["sections"]
 
+        self.step_length = step_length
+
         self.drone = airsim.MultirotorClient(ip=ip_address)
         self.observation_space = gym.spaces.Box(low=0, high=255, shape=self.image_shape, dtype=np.uint8)
         self.action_space = gym.spaces.Discrete(9)
+        #self.action_space = gym.spaces.Discrete(7)
 
         self.info = {"collision": False}
 
+        self.last_position = None
+        self.last_time = None
+
+
         self.collision_time = 0
         self.random_start = True
+        self.current_vy = 0  # Initialize current vertical velocity
+        self.current_vz = 0 
+        self.current_speed = 0
         self.setup_flight()
 
     def step(self, action):
+        #self.do_action(action)
         self.do_action(action)
         obs, info = self.get_obs()
         reward, done = self.compute_reward()
@@ -66,16 +81,17 @@ class AirSimDroneEnv(gym.Env):
         # Prevent drone from falling after reset
         #self.drone.moveToZAsync(-1, 1)
 
-        self.drone.moveToPositionAsync(-20.55265, 0.9786, -10.0225, 5).join()
-        self.drone.simSetCameraPose("0", airsim.Pose(airsim.Vector3r(0, 0, 0), airsim.to_quaternion(math.radians( current_degree-5 ), 0, 0)))
+        #self.drone.moveToPositionAsync(-20.55265, 0.9786, -10.0225, 5).join()
+        #self.drone.simSetCameraPose("0", airsim.Pose(airsim.Vector3r(0, 0, 0), airsim.to_quaternion(math.radians( current_degree-5 ), 0, 0)))
         
 
-        self.drone.moveByRollPitchYawrateZAsync(0, 0, 2.85, self.drone.getMultirotorState().kinematics_estimated.position.z_val, 1).join()
-        self.drone.moveToPositionAsync(-20.55265, 0.9786, -10.0225, 5).join()
-
+        self.drone.moveByRollPitchYawrateZAsync(0, 0, 6.3, self.drone.getMultirotorState().kinematics_estimated.position.z_val, 1).join()
+        self.drone.moveToPositionAsync(-0.55265, 0.9786, -1.0225, 5).join()
+        time.sleep(1)
         # Get collision time stamp
         self.collision_time = self.drone.simGetCollisionInfo().time_stamp
 
+
     def do_action_new_with_rotate(self, select_action):
         speed = 1.5
         yaw_rate = 45  # This is an example value, representing 45 degrees per second. Adjust as needed.
@@ -112,9 +128,86 @@ class AirSimDroneEnv(gym.Env):
         self.drone.moveByVelocityAsync(vx=0, vy=0, vz=0, duration=1)
         # Assuming the drone API has a method to stop yaw rotation. If not, you'll need to find the appropriate method.
         self.drone.stopYaw()
+    def do_action_best(self, action):
+            velocity_multiplier = 1.0
+            #global debug_counter 
+
+            if action == 0:
+                quad_offset = (self.step_length, 0, 0)
+            elif action == 1:
+                quad_offset = (0, self.step_length, 0)
+            elif action == 2:
+                quad_offset = (0, 0, self.step_length)
+            elif action == 3:
+                quad_offset = (-self.step_length, 0, 0)
+            elif action == 4:
+                quad_offset = (0, -self.step_length, 0)
+            elif action == 5:
+                quad_offset = (0, 0, -self.step_length)
+            else:
+                quad_offset = (0, 0, 0)
+
+
+            quad_vel = self.drone.getMultirotorState().kinematics_estimated.linear_velocity
+
+            velocity_x = velocity_multiplier * quad_vel.x_val 
+            velocity_y = velocity_multiplier * quad_vel.y_val
+            velocity_z = velocity_multiplier * quad_vel.z_val
+            
+            # new
+            #debug_counter += 1
+            #print("Speeds: ", round(velocity_x,3), round(velocity_y,3), round(velocity_z,3), debug_counter)
+            self.drone.moveByVelocityAsync(
+                velocity_x + quad_offset[0],
+                velocity_y + quad_offset[1],
+                velocity_z + quad_offset[2],
+                0.5,
+            ).join()
+
+
+    def do_action_loaded_model(self, select_action):
+        # Define target velocities for each action
+        action_velocities = {
+            0: (-1.0, -1.0),
+            1: (0, -1.0),
+            2: (1.0, -1.0),
+            3: (-1.0, 0),
+            4: (0, 0),
+            5: (1.0, 0),
+            6: (-1.0, 1.0),
+            7: (0, 1.0),
+            8: (1.0, 1.0)
+        }
+
+        target_vy, target_vz = action_velocities.get(select_action, (0, 0))
+        # Assuming maximum speed is 1.0, adjust as per your drone's capabilities
+        #max_speed = 5.0
+        max_speed = 3.0
+        # Determine the target speed based on the action
+        target_speed = max_speed if select_action != 4 else 0  # 0 speed for stationary action
+
+        # Total duration of the action
+        total_duration = 0.1
+        # Number of steps for gradual change
+        steps = 10
+        # Duration of each step
+        step_duration = total_duration / steps
+
+        # Gradually change velocity and speed
+        for i in range(1, steps + 1):
+            # Interpolate speed
+            interpolated_speed = self.current_speed + (target_speed - self.current_speed) * i / steps
+
+            # Move the drone with interpolated velocity and speed
+            self.drone.moveByVelocityBodyFrameAsync(interpolated_speed, target_vy, target_vz, duration=step_duration).join()
+
+            # Update current velocities and speed
+            self.current_speed = interpolated_speed
 
     def do_action(self, select_action):
-        speed = 1.5
+        """was speed = 1.0 and worked"""
+        #speed = 3.0
+        speed = 3.0
         if select_action == 0:
             vy, vz = (-speed, -speed)
         elif select_action == 1:
@@ -134,11 +227,8 @@ class AirSimDroneEnv(gym.Env):
         else:
             vy, vz = (speed, speed)
 
-        # Execute action
-        self.drone.moveByVelocityBodyFrameAsync(speed, vy, vz, duration=1).join()
 
-        # # Prevent swaying
-        self.drone.moveByVelocityAsync(vx=0, vy=0, vz=0, duration=1)
+        self.drone.moveByVelocityBodyFrameAsync(speed, vy, vz, duration=0.1).join()
 
     def get_obs(self):
         self.info["collision"] = self.is_collision()
@@ -147,6 +237,35 @@ class AirSimDroneEnv(gym.Env):
 
 
     def compute_reward(self):
+        global previous_x
+
+        # Get current x position
+        pose = self.drone.simGetVehiclePose().position
+        x1 = pose.x_val
+
+        # Compute x difference traveled
+        if 'previous_x' not in globals():
+            previous_x = x1  # Initialize if not present
+        x_difference = previous_x - x1
+        previous_x = x1  # Update previous_x for the next step
+
+        # Use x_difference as the reward
+        reward = x_difference 
+        
+        #keeps wanting to just hover in place, counter this:
+        if reward < 0.1 and reward >= 0: reward = -0.1
+
+        done = False
+        if self.is_collision():
+            done = True
+            reward = -10  # Penalty for collision
+            previous_x = 0
+
+        #print(reward)
+        return reward, done
+
+
+    def compute_reward_old(self):
         global first_pass
         global counter
         global frame_time
@@ -238,7 +357,7 @@ class AirSimDroneEnv(gym.Env):
         x1 = pose.x_val
         y1 = pose.y_val
         z1 = pose.z_val
-        #print(pose)
+        print(pose)
 
         # bus point
         x2, y2, z2 = -110, 0, 0
@@ -346,65 +465,28 @@ class AirSimDroneEnv(gym.Env):
         #print("Final reward: ", reward)
         return reward, done
 
-    def compute_reward_his(self):
-        reward = 0
-        done = 0
-
-        # Target distance based reward
-        x,y,z = self.drone.simGetVehiclePose().position
-        target_dist_curr = np.linalg.norm(np.array([y,-z]) - self.target_pos)
-        reward += (self.target_dist_prev - target_dist_curr)*20
-
-        self.target_dist_prev = target_dist_curr
-
-        # Get meters agent traveled
-        agent_traveled_x = np.abs(self.agent_start_pos - x)
-
-        # Alignment reward
-        if target_dist_curr < 0.30:
-            reward += 12
-            # Alignment becomes more important when agent is close to the hole 
-            if agent_traveled_x > 2.9:
-                reward += 7
-
-        elif target_dist_curr < 0.45:
-            reward += 7
-
-        # Collision penalty
-        if self.is_collision():
-            reward = -100
-            done = 1
-
-        # Check if agent passed through the hole
-        elif agent_traveled_x > 3.7:
-            reward += 10
-            done = 1
-
-        # Check if the hole disappeared from camera frame
-        # (target_dist_curr-0.3) : distance between agent and hole's end point
-        # (3.7-agent_traveled_x) : distance between agent and wall
-        # (3.7-agent_traveled_x)*sin(60) : end points that camera can capture
-        # FOV : 120 deg, sin(60) ~ 1.732 
-        elif (target_dist_curr-0.3) > (3.7-agent_traveled_x)*1.732:
-            reward = -100
-            done = 1
-
-        return reward, done
 
     def is_collision(self):
         current_collision_time = self.drone.simGetCollisionInfo().time_stamp
         return True if current_collision_time != self.collision_time else False
     
     def get_rgb_image(self):
+        #global pic_counter 
         rgb_image_request = airsim.ImageRequest(1, airsim.ImageType.Scene, False, False)
         responses = self.drone.simGetImages([rgb_image_request])
         img1d = np.fromstring(responses[0].image_data_uint8, dtype=np.uint8)
         img2d = np.reshape(img1d, (responses[0].height, responses[0].width, 3)) 
 
+        #pic_counter += 1
+        # Save the image using OpenCV
+        #save_path = "D:\\Home\\Images\\"+str(pic_counter)+".png"
+        #cv2.imwrite(save_path, img2d)
+
         # Sometimes no image returns from api
         try:
             return img2d.reshape(self.image_shape)
         except:
+            print("No picuture")
             return np.zeros((self.image_shape))
 
     def get_depth_image(self, thresh = 2.0):
diff --git a/settings.json b/settings.json
index 817ef41..ae254c3 100644
--- a/settings.json
+++ b/settings.json
@@ -1,82 +1,46 @@
 {
-    "SettingsVersion": 1.2,
-    "SimMode": "Multirotor",
-    "ClockSpeed": 40,
-    "EngineSound": false,
-    "ViewMode": "SpringArmChase",
-    
+  "SettingsVersion": 1.2,
+  "SimMode": "Multirotor",
+  "ClockSpeed": 1,
+  "EngineSound": false,
+  "ViewMode": "SpringArmChase",
   
-  
-    "Recording": {
-      "RecordOnMove": false,
-      "Folder": "",
-      "Enabled": false,
-      "RecordInterval": 0.1,
-      "Cameras": [
-        {
-          "CameraName": "3",
-          "ImageType": 0,
-          "Width": 1920,
-          "Height": 1080,
-          "PixelsAsFloat": false,
-          "Compress": true 
-        }
-      ]
-    },
-  
-    "CameraDefaults": {
-      "CaptureSettings": [
-        {
-          "camera_name": "3",
-          "ImageType": 0,
-          "Width": 1920,
-          "Height": 1080,
-          "FOV_Degrees": 120,
-          "AutoExposureSpeed": 100,
-          "AutoExposureBias": -1,
-          "AutoExposureMaxBrightness": 0.40,
-          "AutoExposureMinBrightness": 0.03,
-          "MotionBlurAmount": 0,
-          "TargetGamma": 1.0,
-          "ProjectionMode": "",
-          "OrthoWidth": 5.12
-        }
-      ],
-      "Gimbal": {
-        "Stabilization": 1,
-        "Pitch": 1,
-        "Roll": 1
+
+
+  "Recording": {
+    "RecordOnMove": false,
+    "Folder": "",
+    "Enabled": false,
+    "RecordInterval": 0.1,
+    "Cameras": [
+      {
+        "CameraName": "3",
+        "ImageType": 0,
+        "Width": 1280,
+        "Height": 720,
+        "PixelsAsFloat": false,
+        "Compress": true 
       }
-    },
-  
-    "Vehicles": {
-      "Drone1": {
-        "VehicleType": "SimpleFlight",
-          "Cameras": {
-            "MyCamera1": {
-              "CaptureSettings": [ 
-                {
-                "ImageType": 0,
-                "Width": 1920,
-                "Height": 1080,
-                "FOV_Degrees": 120
-                }
-                ],
-                "X": -0.1,
-                "Y": 0,
-                "Z": -0.4,
-                "Pitch": 0,
-                "Roll": 0,
-                "Yaw": 0
-                }
-                },
-                "X": 0,
-                "Y": 0,
-                "Z": 0,
-                "Pitch": 0,
-                "Roll": 0,
-                "Yaw": 0
-                }
-                }
-            }
-  
\ No newline at end of file
+    ]
+  },
+
+  "CameraDefaults": {
+    "CaptureSettings": [
+      {
+        "camera_name": "3",
+        "ImageType": 0,
+        "Width": 1280,
+        "Height": 720,
+        "FOV_Degrees": 120,
+        "AutoExposureSpeed": 100,
+        "AutoExposureBias": -1,
+        "AutoExposureMaxBrightness": 0.40,
+        "AutoExposureMinBrightness": 0.03,
+        "MotionBlurAmount": 0,
+        "TargetGamma": 1.0,
+        "ProjectionMode": "",
+        "OrthoWidth": 5.12
+      }
+    ]
+  }
+}
